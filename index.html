<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fappy Bird</title>
    <!-- Importing a pixel-style font for a retro game feel -->
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        /* Basic CSS Reset */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden; /* Prevents scrollbars */
        }

        /* Main styling for the page */
        body {
            background-color: #1a1a2e; /* A dark blue background */
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            font-family: 'Press Start 2P', cursive; /* Applying the retro font */
            text-align: center;
        }

        /* Styling for the game title */
        h1 {
            color: #f7b733; /* Bright yellow color */
            margin-bottom: 1rem;
            text-shadow: 2px 2px #d9534f; /* A red shadow for depth */
        }

        /* Styling for the game canvas */
        canvas {
            background-color: #03131a; /* Sky blue background for the game area */
            border-radius: 12px;
            /* box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5); */ /* Removed for performance */
            border: 4px solid #162447;
            display: block; /* Ensures it behaves as a block-level element */
        }
    </style>
</head>
<body>
    <h1>Fappy Bird</h1>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- Game Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Set base game dimensions for a consistent aspect ratio
        const gameWidth = 480;
        const gameHeight = 640;
        canvas.width = gameWidth;
        canvas.height = gameHeight;

        // --- Responsive Canvas Sizing ---
        function resizeGame() {
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const gameAspectRatio = gameWidth / gameHeight;
            const viewportAspectRatio = viewportWidth / viewportHeight;

            let newCanvasWidth, newCanvasHeight;

            // Adjust canvas size based on which dimension is the constraint, using 90% of the viewport
            if (viewportAspectRatio > gameAspectRatio) {
                // Viewport is wider than the game, so height is the limiting factor
                newCanvasHeight = viewportHeight * 0.9;
                newCanvasWidth = newCanvasHeight * gameAspectRatio;
            } else {
                // Viewport is taller than the game, so width is the limiting factor
                newCanvasWidth = viewportWidth * 0.9;
                newCanvasHeight = newCanvasWidth / gameAspectRatio;
            }

            canvas.style.width = `${newCanvasWidth}px`;
            canvas.style.height = `${newCanvasHeight}px`;
        }

        // --- Game Constants ---
        const BIRD_WIDTH = 40;
        const BIRD_HEIGHT = 30;
        const BIRD_X = gameWidth / 4;
        const GRAVITY = 900; // pixels per second per second (doubled)
        const FLAP_STRENGTH = -440; // pixels per second (instantaneous velocity change) (doubled)

        const PIPE_WIDTH = 70;
        const PIPE_GAP = 250; // Wider gap for easier passage
        const PIPE_SPEED = -180; // pixels per second (doubled)
        const PIPE_SPAWN_INTERVAL = 1.25; // seconds between pipes (halved)

        // --- Game Variables ---
        let birdY, birdVelocity;
        let pipes;
        let timeSinceLastPipe;
        let score;
        let gameState; // 'start', 'playing', 'gameOver'
        let waterSplashes;
        let lastTime; // For delta time calculation

        // --- Sound Effects ---
        const flapSound = new Audio('effectSN.wav'); // Sound for flapping
        flapSound.onerror = () => {
            console.warn("Could not load flap sound 'effectSN.wav'. Make sure the file is in the same folder as the HTML file.");
        };
        const crashSound = new Audio('effectEND.wav'); // Sound for crashing
        crashSound.onerror = () => {
            console.warn("Could not load crash sound 'effectEND.wav'. Make sure the file is in the same folder as the HTML file.");
        };


        // --- Bird Object ---
        const bird = {
            draw: () => {
                ctx.fillStyle = '#f7b733'; // Yellow color for the bird
                ctx.fillRect(BIRD_X, birdY, BIRD_WIDTH, BIRD_HEIGHT);
                // ctx.strokeRect(BIRD_X, birdY, BIRD_WIDTH, BIRD_HEIGHT); // Removed for performance
            },
            update: (deltaTime) => {
                birdVelocity += GRAVITY * deltaTime;
                birdY += birdVelocity * deltaTime;
            },
            flap: () => {
                // Provides the upward thrust and handles starting the game
                if (gameState === 'playing' || gameState === 'start') {
                    flapSound.currentTime = 0;
                    flapSound.play().catch(e => console.error("Error playing sound:", e));
                    if (gameState === 'start') {
                       gameState = 'playing';
                    }
                    birdVelocity = FLAP_STRENGTH;
                }
            }
        };

        // --- Pipe Functions ---
        function createPipe() {
            // Randomly determines the vertical position of the pipe gap
            const gapY = Math.random() * (canvas.height - PIPE_GAP - 100) + 50;
            return {
                x: canvas.width,
                topHeight: gapY,
                bottomY: gapY + PIPE_GAP,
                scored: false
            };
        }

        function updateAndDrawPipes(deltaTime) {
            for (let i = pipes.length - 1; i >= 0; i--) {
                const p = pipes[i];
                p.x += PIPE_SPEED * deltaTime; // Move pipe based on time

                // Draw the pipes
                ctx.fillStyle = '#27ae60'; // Green color for pipes

                // Top pipe
                ctx.fillRect(p.x, 0, PIPE_WIDTH, p.topHeight);
                // ctx.strokeRect(p.x, 0, PIPE_WIDTH, p.topHeight); // Removed for performance

                // Bottom pipe
                ctx.fillRect(p.x, p.bottomY, PIPE_WIDTH, canvas.height - p.bottomY);
                // ctx.strokeRect(p.x, p.bottomY, PIPE_WIDTH, canvas.height - p.bottomY); // Removed for performance


                // --- Scoring ---
                // If the bird has passed the pipe, increment score
                if (!p.scored && p.x + PIPE_WIDTH < BIRD_X) {
                    score++;
                    p.scored = true;
                }

                // --- Collision Detection ---
                if (
                    BIRD_X < p.x + PIPE_WIDTH &&
                    BIRD_X + BIRD_WIDTH > p.x &&
                    (birdY < p.topHeight || birdY + BIRD_HEIGHT > p.bottomY)
                ) {
                    endGame();
                }

                // Remove pipes that are off-screen
                if (p.x + PIPE_WIDTH < 0) {
                    pipes.splice(i, 1);
                }
            }
        }

        // --- Game State & UI ---
        function drawUI() {
            ctx.fillStyle = 'white'; // Changed to white for better visibility without stroke
            ctx.textAlign = 'center';

            if (gameState === 'start') {
                ctx.font = "24px 'Press Start 2P'";
                ctx.fillText('Click or Tap', canvas.width / 2, canvas.height / 2 - 20);
                ctx.font = "20px 'Press Start 2P'";
                ctx.fillText('to Flap!', canvas.width / 2, canvas.height / 2 + 20);
            } else if (gameState === 'gameOver') {
                ctx.font = "40px 'Press Start 2P'";
                ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2 - 50);

                ctx.font = "24px 'Press Start 2P'";
                ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2);

                ctx.font = "16px 'Press Start 2P'";
                ctx.fillText('Click to Restart', canvas.width / 2, canvas.height / 2 + 50);
            }

            // Always draw the score while playing
            if (gameState === 'playing' || gameState === 'gameOver') {
                ctx.font = "40px 'Press Start 2P'";
                ctx.fillText(score, canvas.width / 2, 70);
            }
        }

        // --- Game Logic ---
        function checkGroundCollision() {
            // Check if bird hits the top or bottom of the canvas
            if (birdY + BIRD_HEIGHT > canvas.height || birdY < 0) {
                endGame();
            }
        }

        function resetGame() {
            birdY = canvas.height / 2;
            birdVelocity = 0;
            pipes = [];
            timeSinceLastPipe = PIPE_SPAWN_INTERVAL; // Spawn a pipe right away on start
            score = 0;
            waterSplashes = []; // Reset the splashes
            gameState = 'start'; // Start with the initial screen
        }
        
        function endGame() {
            if (gameState === 'playing') {
                crashSound.currentTime = 0;
                crashSound.play().catch(e => console.error("Error playing crash sound:", e));
                createSplashes(25); // Reduced from 50 to 25 for better performance
                gameState = 'gameOver';
            }
        }

        // --- Game Over Effects ---
        function createSplashes(count) {
            for (let i = 0; i < count; i++) {
                const size = Math.random() * 30 + 20;
                let x, y, vx, vy;
                const side = Math.floor(Math.random() * 4); // 0: top, 1: right, 2: bottom, 3: left

                switch(side) {
                    case 0: // From Top
                        x = Math.random() * canvas.width;
                        y = -size;
                        vx = Math.random() * 2 - 1; // Slower horizontal speed
                        vy = Math.random() * 0.5; // Slower vertical speed
                        break;
                    case 1: // From Right
                        x = canvas.width + size;
                        y = Math.random() * canvas.height;
                        vx = -(Math.random() * 1.5 + 0.5); // Slower horizontal speed
                        vy = Math.random() * 0.5; // Slower vertical speed
                        break;
                    case 2: // From Bottom
                        x = Math.random() * canvas.width;
                        y = canvas.height + size;
                        vx = Math.random() * 2 - 1; // Slower horizontal speed
                        vy = -(Math.random() * 0.5 + 0.5); // Slower vertical speed
                        break;
                    case 3: // From Left
                        x = -size;
                        y = Math.random() * canvas.height;
                        vx = Math.random() * 1.5 + 0.5; // Slower horizontal speed
                        vy = Math.random() * 0.5; // Slower vertical speed
                        break;
                }
                
                waterSplashes.push({ x, y, vx, vy, size });
            }
        }

        function updateAndDrawSplashes() {
            for (let s of waterSplashes) {
                s.x += s.vx;
                s.y += s.vy;
                s.vy += 0.05; // Less gravity for a slower, more floaty effect

                ctx.font = `${s.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('ðŸ’¦', s.x, s.y);
            }
        }


        // --- Main Game Loop ---
        function gameLoop(currentTime) {
            // Calculate delta time (time since last frame)
            if (!lastTime) {
                lastTime = currentTime;
            }
            const deltaTime = (currentTime - lastTime) / 1000; // Time in seconds
            lastTime = currentTime;


            // Clear the canvas for the next frame
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameState === 'playing') {
                // Spawn new pipes at intervals
                timeSinceLastPipe += deltaTime;
                if (timeSinceLastPipe >= PIPE_SPAWN_INTERVAL) {
                    pipes.push(createPipe());
                    timeSinceLastPipe = 0;
                }

                // Update game elements
                bird.update(deltaTime);
                updateAndDrawPipes(deltaTime);
                checkGroundCollision();
            }

            // Draw game elements
            bird.draw();
            
            // Draw splashes if the game is over
            if (gameState === 'gameOver') {
                updateAndDrawSplashes();
            }

            drawUI();

            // Request the next frame
            requestAnimationFrame(gameLoop);
        }
        
        // --- Event Listeners ---
        function handleInput(e) {
             if (e.code === 'Space' || e.type === 'mousedown' || e.type === 'touchstart') {
                if (gameState === 'start' || gameState === 'playing') {
                    bird.flap();
                } else if (gameState === 'gameOver') {
                    resetGame(); // Allow restart from the game over screen
                }
             }
        }

        window.addEventListener('keydown', handleInput);
        window.addEventListener('mousedown', handleInput);
        window.addEventListener('touchstart', handleInput);
        window.addEventListener('resize', resizeGame); // Add resize listener

        // --- Initialize and Start ---
        resetGame(); // Set up the initial state
        resizeGame(); // Set initial canvas size based on the window
        requestAnimationFrame(gameLoop); // Start the game loop
    </script>
</body>
</html>


